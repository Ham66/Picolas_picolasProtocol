#!/usr/bin/env python
# -*- coding:utf-8 -*-


# ############################################################################
#  license :
# ============================================================================
#
#  File :        Picolas.py
#
#  Project :     
#
# This file is part of Tango device class.
# 
# Tango is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tango is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tango.  If not, see <http://www.gnu.org/licenses/>.
# 
#
#  $Author :      maxim.stassevich$
#
#  $Revision :    $
#
#  $Date :        $
#
#  $HeadUrl :     $
# ============================================================================
#            This file is generated by POGO
#     (Program Obviously used to Generate tango Object)
# ############################################################################

__all__ = ["Picolas", "PicolasClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(Picolas.additionnal_import) ENABLED START -----#
PING_S = 0xFE01
IDENT_S = 0xFE02
GETHARDVER_S = 0xFE06
GETSOFTVER_S = 0xFE07
GETSERIAL_S = 0xFE08
GETIDSTRING_S = 0xFE09
GETDEVICECHECKSUM_S = 0xFE0A
RESET_S = 0xFE0E

GETCPUTEMP_S = 0x0001
GETDEVTEMP_S = 0x0002
GETVOLMIN_S = 0x0003
GETVOLMAX_S = 0x0004 
GETVOLSET_S = 0x0005
GETVOLACT_S = 0x0006
GETVOLPERSTEP_S = 0x0007
GETCURVAL_S = 0x0008
GETLSTAT_S = 0x0009
GETDEVID_S = 0x000A
GETPULSEWIDTH_S = 0x000B
GETPULSEWIDTHMIN_S = 0x000C
GETPULSEWIDTHAX_S = 0x000D
GETREPRATE_S = 0x000E
GETREPRATEMIN_S = 0x000F
GETREPRATEMAX_S = 0x0010
GETSHOTS_S = 0x0011
GETSHOTSMIN_S = 0x0012
GETSHOTSMAX_S = 0x0013
GETOVERCUR_S = 0x0014
GETOVERCURMIN_S = 0x0015
GETOVERCURMAX_S = 0x0016
GETOVERCURVAL_S = 0x0017
GETDEVTEMPOFF_S = 0x001B
GETDEVTEMPOFFMIN_S = 0x001C
GETDEVTEMPOFFMAX_S = 0x001D
GETUMIN_S = 0x001E
GETERROR_S = 0x001F
GETDEVICENAME_S = 0x0022
SETVOL_S = 0x0030
SETLSTAT_S = 0x0031
SETREPRATE_S = 0x0032
SETPULSEWIDTH_S = 0x0033
SETSHOTS_S = 0x0034
SETOVERCUR_S = 0x0035
SETDEVTEMPOFF_S = 0x0036
SETUMIN_S = 0x0038
CLEARERROR_S = 0x0039
EXECCAL_S = 0x003A
RSTDEF_S = 0x003C

PING_R = 0xFF01
IDENT_R = 0xFF02
GETHARDVER_R = 0xFF06
GETSOFTVER_R = 0xFF07
GETSERIAL_R = 0xFF08
GETIDSTRING_R = 0xFF09
GETDEVICECHECKSUM_R = 0xFF0A
RESET_R = 0xFF0B

GETCPUTEMP_R = 0x0050
GETDEVTEMP_R = 0x0050
GETVOLMIN_R = 0x0053
GETVOLMAX_R = 0x0053 
GETVOLSET_R = 0x0053
GETVOLACT_R = 0x0053
GETVOLPERSTEP_R = 0x0053
GETCURVAL_R = 0x0052
GETLSTAT_R = 0x0054
GETDEVID_R = 0x0055
GETPULSEWIDTH_R = 0x0056
GETPULSEWIDTHMIN_R = 0x0056
GETPULSEWIDTHAX_R = 0x0056
GETREPRATE_R = 0x0057
GETREPRATEMIN_R = 0x0057
GETREPRATEMAX_R = 0x0057
GETSHOTS_R = 0x0058
GETSHOTSMIN_R = 0x0058
GETSHOTSMAX_R = 0x0058
GETOVERCUR_R = 0x0052
GETOVERCURMIN_R = 0x0052
GETOVERCURMAX_R = 0x0052
GETOVERCURVAL_R = 0x0052
GETDEVTEMPOFF_R = 0x0050
GETDEVTEMPOFFMIN_R = 0x0050
GETDEVTEMPOFFMAX_R = 0x0050
GETUMIN_R = 0x0051
GETERROR_R = 0x0059
GETDEVICENAME_R = 0x005C
SETVOL_R = 0x0053
SETLSTAT_R = 0x0054
SETREPRATE_R = 0x0057
SETPULSEWIDTH_R = 0x0056
SETSHOTS_R = 0x0058
SETOVERCUR_R = 0x0052
SETDEVTEMPOFF_R = 0x0050
SETUMIN_R = 0x0053
CLEARERROR_R = 0x005A
EXECCAL_R = 0x005B
RSTDEF_R = 0x0060

ILGLPARAM = 0xFF12
UNCOM = 0xFF13
RXERROR = 0xFF10

ILGLPARAM_S = "Illegal parameter!!!"
UNCOM_S = "Invalid command!!!"
RXERROR_S = "Checksum error!!!"

IMAX_OVERSTEPPED = "The PLCS measured a pulse current larger than the set value and has switched off"
CPUTEMP_OVERSTEPPED = "The PLCS has exceeded its permitted operating temperature of 80 Â°C"
DEVICETEMP_WARN = "The temperature of the connected pulser is approaching the switch-off temperature"
DEVICETEMP_OVERSTEPPED = "The switch-off temperature of the connected pulser has been reached"
DEVICETEMP_HYSTERESIS = "The connected pulser is currently in the cooling phase"
DEVICETEMP_SENSORFAILED = "The temperature sensor in the pulser is defective"
DEVICE_FAILED = "The connected pulser is defective"
NODEVICE = "No connected pulser was detected"
CALERROR = "An error occurred during calibration"
TBL_FAIL = "No data was found for the connected pulser, a software update is necessary"
U_15V_FAIL = "The supply voltage is too low"
INTERNAL_ERROR = "An internal error occurred. Please contact support"
FAULTY_ID = "The connected pulser has an invalid ID"

NO_CONNECTION = "Could not recieve data from PILC, check the connection and Init device!!!"
CORRECT_ACKNOWLEDGE = "OK"


import threading
import serial
import time


class readWritePicolas(threading.Thread):
    def __init__(self, ser):
        threading.Thread.__init__(self)
        self.running = True
        self.commandAllowed = False
        self.command = ""
        self.parameter = ""
        self.expectedAnswer = ""
        self.states = {"calibration": False, "running": False, "fault": False, "error": False}
        self.status = ""
        self.globalInterator = 0
        
        self.pulse = None
        self.reprate = None
        self.voltage = None
        self.current = None
        self.shots = None
        self.trgmode = None
        self.umin = None
        self.imax = None
        self.mode = None
        
        self.ser = ser
        
        self.LSTAT = 0
        self.parameter_status = CORRECT_ACKNOWLEDGE
        
        print "Starting thread"
        
    def run(self):
        while self.running:
            try:
                if self.commandAllowed:
                    
                    parameter, self.parameter_status = self.getAttribute(self.command, self.parameter, self.expectedAnswer)
                    if self.parameter_status == RXERROR_S:
                        self.status = "Couldn't send command. " + RXERROR_S
                    if self.parameter_status == ILGLPARAM_S:
                        self.status = "Couldn't send command. " + ILGLPARAM_S
                    if self.parameter_status == UNCOM_S:
                        self.status = "Couldn't send command. " + UNCOM_S
                    #if parameter_status == NO_CONNECTION:
                    #    self.status = NO_CONNECTION
                    #    self.states["fault"] = True
                    #if parameter_status == CORRECT_ACKNOWLEDGE:
                    #    self.status = CORRECT_ACKNOWLEDGE
                    if self.parameter_status == CORRECT_ACKNOWLEDGE and self.command == EXECCAL_S and parameter != 0:
                        self.parameter_status = "Currently not possible to carry out a calibration"
                        self.status = "Currently not possible to carry out a calibration"
                            
                    self.command = ""
                    self.parameter = ""
                    self.expectedAnswer = ""
                    self.commandAllowed = False
                
                self.LSTAT, lstat_status = self.getAttribute(GETLSTAT_S, 0, GETLSTAT_R)
                if lstat_status == RXERROR_S:
                    self.status = "Couldn't read LSTAT register " + RXERROR_S
                    self.states["fault"] = True
                if lstat_status == ILGLPARAM_S:
                    self.status = "Couldn't read LSTAT register " + ILGLPARAM_S
                    self.states["fault"] = True
                if lstat_status == UNCOM_S:
                    self.status = "Couldn't read LSTAT register " + UNCOM_S
                    self.states["fault"] = True
                if lstat_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                if lstat_status == CORRECT_ACKNOWLEDGE:
                    #self.status = CORRECT_ACKNOWLEDGE
                    device_on = self.LSTAT & 0x01
                    norm_or_gener_mode = self.LSTAT & (1 << 1) #0x02
                    trg_mode1 = self.LSTAT & (1 << 2) #0x04
                    trg_mode2 = self.LSTAT & (1 << 3) #0x08
                    trg_mode3 = self.LSTAT & (1 << 4) #0x10
                    trg_mode4 = self.LSTAT & (1 << 5) #0x20
                    vol_or_cur_mode = (self.LSTAT >> 8) & 0x01
                    UNCAL = (self.LSTAT >> 8) & 0x02
                    CALIBRATING = (self.LSTAT >> 8) & 0x04
                    BUSY = (self.LSTAT >> 8) & 0x10
                    INIT_COMPLETE = (self.LSTAT >> 8) & 0x20
                    DEVICE_CHANGED = (self.LSTAT >> 8) & 0x40
                    if device_on == 0:
                        self.states["running"] = False
                    else:
                        self.states["running"] = True
                    if CALIBRATING == 0:
                        self.states["calibration"] = False
                    else:
                        self.states["calibration"] = True
                    if trg_mode1 == 0 and trg_mode2 == 0 and trg_mode3 == 0 and trg_mode4 == 0:
                        self.trgmode = 0
                    elif trg_mode1 != 0 and trg_mode2 == 0 and trg_mode3 == 0 and trg_mode4 == 0:
                        self.trgmode = 1
                    elif trg_mode1 == 0 and trg_mode2 != 0 and trg_mode3 == 0 and trg_mode4 == 0:
                        self.trgmode = 2
                    elif trg_mode1 != 0 and trg_mode2 != 0 and trg_mode3 == 0 and trg_mode4 == 0:
                        self.trgmode = 3
                    elif trg_mode1 == 0 and trg_mode2 == 0 and trg_mode3 != 0 and trg_mode4 == 0:
                        self.trgmode = 4
                    else:
                        self.trgmode = 5
                    if norm_or_gener_mode == 0:
                        if vol_or_cur_mode == 0:
                            self.mode = 2
                        else:
                            self.mode = 1
                    else:
                        self.mode = 0
                    #print trg_mode1, trg_mode2, trg_mode3, trg_mode4
                    #print self.trgmode, self.mode
                #print "LSTAT ", self.LSTAT, lstat_status
                      
                errorRegister, error_status = self.getAttribute(GETERROR_S, 0, GETERROR_R)
                if error_status == RXERROR_S:
                    self.status = "Couldn't read ERROR register " + RXERROR_S
                    self.states["fault"] = True
                if error_status == ILGLPARAM_S:
                    self.status = "Couldn't read ERROR register " + ILGLPARAM_S
                    self.states["fault"] = True
                if error_status == UNCOM_S:
                    self.status = "Couldn't read ERROR register " + UNCOM_S
                    self.states["fault"] = True
                if error_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                if error_status == CORRECT_ACKNOWLEDGE:
                    #self.status = CORRECT_ACKNOWLEDGE
                    if ((errorRegister & 0x01) != 0):
                        error_status = IMAX_OVERSTEPPED
                        self.status = IMAX_OVERSTEPPED
                        self.states["error"] = True
                    elif ((errorRegister & 0x08) != 0):
                        error_status = CPUTEMP_OVERSTEPPED
                        self.status = CPUTEMP_OVERSTEPPED
                        self.states["error"] = True
                    elif ((errorRegister & 0x20) != 0):
                        error_status = DEVICETEMP_WARN
                        self.status = DEVICETEMP_WARN
                        self.states["error"] = True
                    elif ((errorRegister & 0x40) != 0):
                        error_status = DEVICETEMP_OVERSTEPPED
                        self.status = DEVICETEMP_OVERSTEPPED
                        self.states["error"] = True
                    elif ((errorRegister & 0x80) != 0):
                        error_status = DEVICETEMP_HYSTERESIS
                        self.status = DEVICETEMP_HYSTERESIS
                        self.states["error"] = True
                    elif (((errorRegister >> 8) & 0x01) != 0):
                        error_status = DEVICETEMP_SENSORFAILED
                        self.status = DEVICETEMP_SENSORFAILED
                        self.states["error"] = True
                    elif (((errorRegister >> 8) & 0x02) != 0):
                        error_status = DEVICE_FAILED
                        self.status = DEVICE_FAILED
                        self.states["error"] = True
                    elif (((errorRegister >> 8) & 0x04) != 0):
                        error_status = NODEVICE
                        self.status = NODEVICE
                        self.states["error"] = True
                    elif (((errorRegister >> 8) & 0x08) != 0):
                        error_status = CALERROR
                        self.status = CALERROR
                        self.states["error"] = True
                    elif (((errorRegister >> 8) & 0x10) != 0):
                        error_status = TBL_FAIL
                        self.status = TBL_FAIL
                        self.states["error"] = True
                    elif (((errorRegister >> 8) & 0x80) != 0):
                        error_status = U_15V_FAIL
                        self.status = U_15V_FAIL
                        self.states["error"] = True
                    elif (((errorRegister >> 16) & 0x01) != 0):
                        error_status = INTERNAL_ERROR
                        self.status = INTERNAL_ERROR
                        self.states["error"] = True
                    elif (((errorRegister >> 16) & 0x02) != 0):
                        error_status = FAULTY_ID
                        self.status = FAULTY_ID
                        self.states["error"] = True
                    elif errorRegister > 0:
                        error_status = "Error!!!"
                        self.states["error"] = True
                    else:
                        self.states["error"] = False
                #print "error register ", errorRegister, error_status
                    
                self.pulse, pulse_status = self.getAttribute(GETPULSEWIDTH_S, 0, GETPULSEWIDTH_R)
                if pulse_status == RXERROR_S:
                    self.status = "Couldn't read pulse width " + RXERROR_S
                    self.states["fault"] = True
                if pulse_status == ILGLPARAM_S:
                    self.status = "Couldn't read pulse width " + ILGLPARAM_S
                    self.states["fault"] = True
                if pulse_status == UNCOM_S:
                    self.status = "Couldn't read pulse width " + UNCOM_S
                    self.states["fault"] = True
                if pulse_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                #if pulse_status == CORRECT_ACKNOWLEDGE:
                #    self.status = CORRECT_ACKNOWLEDGE
                #print "pulse ", self.pulse, pulse_status
                
                self.reprate, reprate_status = self.getAttribute(GETREPRATE_S, 0, GETREPRATE_R)
                if reprate_status == RXERROR_S:
                    self.status = "Couldn't read repeat rate " + RXERROR_S
                    self.states["fault"] = True
                if reprate_status == ILGLPARAM_S:
                    self.status = "Couldn't read repeat rate " + ILGLPARAM_S
                    self.states["fault"] = True
                if reprate_status == UNCOM_S:
                    self.status = "Couldn't read repeat rate " + UNCOM_S
                    self.states["fault"] = True
                if reprate_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                #if reprate_status == CORRECT_ACKNOWLEDGE:
                #    self.status = CORRECT_ACKNOWLEDGE
                #print "reprate ", self.reprate, reprate_status
                
                convFactorVol, convFactorVol_status = self.getAttribute(GETVOLPERSTEP_S, 0, GETVOLPERSTEP_R)
                if convFactorVol_status == RXERROR_S:
                    self.status = "Couldn't read conversion factor " + RXERROR_S
                    self.states["fault"] = True
                if convFactorVol_status == ILGLPARAM_S:
                    self.status = "Couldn't read conversion factor " + ILGLPARAM_S
                    self.states["fault"] = True
                if convFactorVol_status == UNCOM_S:
                    self.status = "Couldn't read conversion factor " + UNCOM_S
                    self.states["fault"] = True
                if convFactorVol_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                #if convFactorVol_status == CORRECT_ACKNOWLEDGE:
                #    self.status = CORRECT_ACKNOWLEDGE
                #print "convFactor ", convFactorVol, convFactorVol_status
                
                self.voltage, voltage_status = self.getAttribute(GETVOLACT_S, 0, GETVOLACT_R)
                self.voltage *= convFactorVol
                if voltage_status == RXERROR_S:
                    self.status = "Couldn't read voltage " + RXERROR_S
                    self.states["fault"] = True
                if voltage_status == ILGLPARAM_S:
                    self.status = "Couldn't read voltage " + ILGLPARAM_S
                    self.states["fault"] = True
                if voltage_status == UNCOM_S:
                    self.status = "Couldn't read voltage " + UNCOM_S
                    self.states["fault"] = True
                if voltage_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                #if voltage_status == CORRECT_ACKNOWLEDGE:
                #    self.status = CORRECT_ACKNOWLEDGE
                #print "voltage ", self.voltage, voltage_status
                
                self.current, current_status = self.getAttribute(GETCURVAL_S, 0, GETCURVAL_R)
                if current_status == RXERROR_S:
                    self.status = "Couldn't read current " + RXERROR_S
                    self.states["fault"] = True
                if current_status == ILGLPARAM_S:
                    self.status = "Couldn't read current " + ILGLPARAM_S
                    self.states["fault"] = True
                if current_status == UNCOM_S:
                    self.status = "Couldn't read current " + UNCOM_S
                    self.states["fault"] = True
                if current_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                #if current_status == CORRECT_ACKNOWLEDGE:
                #    self.status = CORRECT_ACKNOWLEDGE
                #print self.current, current_status
                
                self.shots, shots_status = self.getAttribute(GETSHOTS_S, 0, GETSHOTS_R)
                if shots_status == RXERROR_S:
                    self.status = "Couldn't read number of pulses to be emitted " + RXERROR_S
                    self.states["fault"] = True
                if shots_status == ILGLPARAM_S:
                    self.status = "Couldn't read number of pulses to be emitted " + ILGLPARAM_S
                    self.states["fault"] = True
                if shots_status == UNCOM_S:
                    self.status = "Couldn't read number of pulses to be emitted " + UNCOM_S
                    self.states["fault"] = True
                if shots_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                #if shots_status == CORRECT_ACKNOWLEDGE:
                #    self.status = CORRECT_ACKNOWLEDGE
                #print "shots ", self.shots, shots_status
                
                self.umin, umin_status = self.getAttribute(GETUMIN_S, 0, GETUMIN_R)
                self.umin *= convFactorVol
                if umin_status == RXERROR_S:
                    self.status = "Couldn't read start voltage for the calibration " + RXERROR_S
                    self.states["fault"] = True
                if umin_status == ILGLPARAM_S:
                    self.status = "Couldn't read start voltage for the calibration " + ILGLPARAM_S
                    self.states["fault"] = True
                if umin_status == UNCOM_S:
                    self.status = "Couldn't read start voltage for the calibration " + UNCOM_S
                    self.states["fault"] = True
                if umin_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                #if umin_status == CORRECT_ACKNOWLEDGE:
                #    self.status = CORRECT_ACKNOWLEDGE
                #print "umin", self.umin, umin_status
                
                self.imax, imax_status = self.getAttribute(GETOVERCURVAL_S, 0, GETOVERCUR_R)
                if imax_status == RXERROR_S:
                    self.status = "Couldn't read value for over-current detection " + RXERROR_S
                    self.states["fault"] = True
                if imax_status == ILGLPARAM_S:
                    self.status = "Couldn't read value for over-current detection " + ILGLPARAM_S
                    self.states["fault"] = True
                if imax_status == UNCOM_S:
                    self.status = "Couldn't read value for over-current detection " + UNCOM_S
                    self.states["fault"] = True
                if imax_status == NO_CONNECTION:
                    self.status = NO_CONNECTION
                    self.states["fault"] = True
                #if imax_status == CORRECT_ACKNOWLEDGE:
                #    self.status = CORRECT_ACKNOWLEDGE
                #print "imax", self.imax, imax_status
                         
                if (self.parameter_status == CORRECT_ACKNOWLEDGE and  lstat_status == CORRECT_ACKNOWLEDGE and error_status == CORRECT_ACKNOWLEDGE and
                     pulse_status == CORRECT_ACKNOWLEDGE and reprate_status == CORRECT_ACKNOWLEDGE and convFactorVol_status == CORRECT_ACKNOWLEDGE and
                      voltage_status == CORRECT_ACKNOWLEDGE and current_status == CORRECT_ACKNOWLEDGE and shots_status == CORRECT_ACKNOWLEDGE and
                       umin_status == CORRECT_ACKNOWLEDGE and imax_status == CORRECT_ACKNOWLEDGE):
                    self.status = CORRECT_ACKNOWLEDGE
                if (lstat_status == CORRECT_ACKNOWLEDGE and error_status == CORRECT_ACKNOWLEDGE and
                     pulse_status == CORRECT_ACKNOWLEDGE and reprate_status == CORRECT_ACKNOWLEDGE and convFactorVol_status == CORRECT_ACKNOWLEDGE and
                      voltage_status == CORRECT_ACKNOWLEDGE and current_status == CORRECT_ACKNOWLEDGE and shots_status == CORRECT_ACKNOWLEDGE and
                       umin_status == CORRECT_ACKNOWLEDGE and imax_status == CORRECT_ACKNOWLEDGE):
                    self.states["fault"] = False
                    
                #print lstat_status, error_status, pulse_status, reprate_status, convFactorVol_status, voltage_status, current_status, shots_status, umin_status, imax_status
                #print "states: ", self.states    
                #self.states["fault"] = False
                
            except:
                self.states["fault"] = True
                self.status = NO_CONNECTION
                time.sleep(0.3)
            #time.sleep(0.7)
        self.ser.close()
        print "Thread exited"
        
    def stop(self):
        print "Exiting thread.."
        self.running = False
    
    def sendCommand(self, command, parameter, expectedAnswer):
        self.command = command
        self.parameter = parameter
        self.expectedAnswer = expectedAnswer
        self.commandAllowed = True
        
    def checkByte(self, bytesBuffer):
        checkByte = 0
        for i in range(len(bytesBuffer) - 1):
            checkByte ^= bytesBuffer[i]
        return checkByte
        
    def sendBytes(self, command, parameter):
        bytesToSend = bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
        bytesToSend[0] = command & 0xFF
        bytesToSend[1] = (command >> 8) & 0xFF
        bytesToSend[2] = parameter & 0xFF
        bytesToSend[3] = (parameter >> 8) & 0xFF
        bytesToSend[4] = (parameter >> 16) & 0xFF
        bytesToSend[5] = (parameter >> 24) & 0xFF
        bytesToSend[6] = (parameter >> 32) & 0xFF
        bytesToSend[7] = (parameter >> 40) & 0xFF
        bytesToSend[8] = (parameter >> 48) & 0xFF
        bytesToSend[9] = (parameter >> 56) & 0xFF
        bytesToSend[11] = self.checkByte(bytesToSend)
        self.ser.flushInput()
        self.ser.flushOutput()
        self.ser.write(bytesToSend)
    
    def getAttribute(self, command, parameter, expectedAnswer):
        recievedCommand = 0
        recievedParameter = None
        status = None
        recievedString = bytearray(b'\x00')
        while(len(recievedString) != 12):
            self.sendBytes(command, parameter)
            time.sleep(0.1)
            recievedString = self.ser.read(12)
            self.globalInterator += 1
            if self.globalInterator > 10:
                self.globalInterator = 0
                status = NO_CONNECTION
                return recievedParameter, status
        self.globalInterator = 0
        recievedBytes = bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
        for i in range(len(recievedString)):
            recievedBytes[i] = int(recievedString[i].encode('hex'), 16)
        if (recievedBytes[11] != self.checkByte(recievedBytes)):
            status = RXERROR_S
            return recievedParameter, status
        recievedCommand = recievedBytes[0]
        recievedCommand += recievedBytes[1] << 8
        recievedParameter = recievedBytes[2]
        recievedParameter += recievedBytes[3] << 8
        recievedParameter += recievedBytes[4] << 16
        recievedParameter += recievedBytes[5] << 24
        recievedParameter += recievedBytes[6] << 32
        recievedParameter += recievedBytes[7] << 40
        recievedParameter += recievedBytes[8] << 48
        recievedParameter += recievedBytes[9] << 56
        if recievedCommand == ILGLPARAM:
            status = ILGLPARAM_S
        elif recievedCommand == UNCOM:
            status = UNCOM_S
        elif recievedCommand == RXERROR:
            status = RXERROR_S
        elif recievedCommand == expectedAnswer:
            status = CORRECT_ACKNOWLEDGE
        else:
            status = NO_CONNECTION
        return recievedParameter, status
    
    def getLSTAT(self):
        return self.LSTAT
    
    def setParameterStatus(self, status):
        self.parameter_status = status
        self.status = status
    
    #def getParameterStatus(self):
    #    return self.parameter_status
    
    def getData(self):
        return (self.status, self.states, self.pulse, self.reprate, self.voltage, self.current, self.shots, self.trgmode,
                self.umin, self.imax, self.mode)

#----- PROTECTED REGION END -----#	//	Picolas.additionnal_import

# Device States Description
# ON : 
# OFF : 
# RUNNING : 
# EXTRACT : 


class Picolas (PyTango.Device_4Impl):
    """Class to control LED driver LDPV-80-100 with PLCS-21"""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(Picolas.global_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Picolas.global_variables

    def __init__(self, cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        Picolas.init_device(self)
        #----- PROTECTED REGION ID(Picolas.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(Picolas.delete_device) ENABLED START -----#
        if self.picolas is not None:
            self.picolas.stop()
        self.set_state(PyTango.DevState.OFF)
        self.set_status("Device is in OFF state")
        #----- PROTECTED REGION END -----#	//	Picolas.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_mode_read = 0
        self.attr_ocur_read = 0
        self.attr_umin_read = 0
        self.attr_trgmode_read = 0
        self.attr_shots_read = 0
        self.attr_current_read = 0
        self.attr_voltage_read = 0
        self.attr_reprate_read = 0
        self.attr_pulse_read = 0
        #----- PROTECTED REGION ID(Picolas.init_device) ENABLED START -----#
        self.picolas = None
        self.ser = None
        try:
            self.ser = serial.Serial(              
                    #port = "/dev/ttyUSB0",
                    port = "/dev/PICOLAS",
                    baudrate = 115200,
                    parity = serial.PARITY_EVEN,
                    stopbits = serial.STOPBITS_ONE,
                    bytesize = serial.EIGHTBITS,
                    timeout = 0.1)
            self.set_state(PyTango.DevState.ON)
            self.set_status(CORRECT_ACKNOWLEDGE)
        except:
            self.set_state(PyTango.DevState.OFF)
            self.set_status(NO_CONNECTION)
        if self.get_state() == PyTango.DevState.ON:
            self.picolas = readWritePicolas(self.ser)
            PING, ping_status = self.picolas.getAttribute(PING_S, 0, PING_R)
            if ping_status == RXERROR_S:
                self.status = "Couldn't switch to PICOLAS protocol " + RXERROR_S
                self.set_state(PyTango.DevState.OFF)
                self.set_status("Couldn't switch to PICOLAS protocol " + RXERROR_S)
            if ping_status == ILGLPARAM_S:
                self.set_state(PyTango.DevState.OFF)
                self.set_status("Couldn't switch to PICOLAS protocol " + ILGLPARAM_S)
            if ping_status == UNCOM_S:
                self.set_state(PyTango.DevState.OFF)
                self.set_status("Couldn't switch to PICOLAS protocol " + UNCOM_S)
            if ping_status == NO_CONNECTION:
                self.set_state(PyTango.DevState.OFF)
                self.set_status(NO_CONNECTION)
            if ping_status == CORRECT_ACKNOWLEDGE:
                self.picolas.start()
        #----- PROTECTED REGION END -----#	//	Picolas.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(Picolas.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.always_executed_hook

    # -------------------------------------------------------------------------
    #    Picolas read/write attribute methods
    # -------------------------------------------------------------------------
    
    def read_mode(self, attr):
        self.debug_stream("In read_mode()")
        #----- PROTECTED REGION ID(Picolas.mode_read) ENABLED START -----#
        attr.set_value(self.attr_mode_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.mode_read
        
    def write_mode(self, attr):
        self.debug_stream("In write_mode()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.mode_write) ENABLED START -----#
        LSTAT = self.picolas.getLSTAT()
        if data == 1:
            LSTAT &= ~(1 << 1);
        elif data == 2:
            LSTAT |= (1 << 1);
        else:
            self.picolas.setParameterStatus("Couldn't send command. " + ILGLPARAM_S)
            return
        self.picolas.sendCommand(SETLSTAT_S, LSTAT, SETLSTAT_R)
        #----- PROTECTED REGION END -----#	//	Picolas.mode_write
        
    def is_mode_allowed(self, attr):
        self.debug_stream("In is_mode_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_mode_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_mode_allowed
        return state_ok
        
    def read_ocur(self, attr):
        self.debug_stream("In read_ocur()")
        #----- PROTECTED REGION ID(Picolas.ocur_read) ENABLED START -----#
        attr.set_value(self.attr_ocur_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.ocur_read
        
    def write_ocur(self, attr):
        self.debug_stream("In write_ocur()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.ocur_write) ENABLED START -----#
        parameter = int(data/25)
        self.picolas.sendCommand(SETOVERCUR_S, parameter, SETOVERCUR_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.ocur_write
        
    def is_ocur_allowed(self, attr):
        self.debug_stream("In is_ocur_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_ocur_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_ocur_allowed
        return state_ok
        
    def read_umin(self, attr):
        self.debug_stream("In read_umin()")
        #----- PROTECTED REGION ID(Picolas.umin_read) ENABLED START -----#
        attr.set_value(self.attr_umin_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.umin_read
        
    def write_umin(self, attr):
        self.debug_stream("In write_umin()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.umin_write) ENABLED START -----#
        parameter = int(data/30)
        self.picolas.sendCommand(SETUMIN_S, parameter, SETUMIN_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.umin_write
        
    def is_umin_allowed(self, attr):
        self.debug_stream("In is_umin_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_umin_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_umin_allowed
        return state_ok
        
    def read_trgmode(self, attr):
        self.debug_stream("In read_trgmode()")
        #----- PROTECTED REGION ID(Picolas.trgmode_read) ENABLED START -----#
        attr.set_value(self.attr_trgmode_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.trgmode_read
        
    def write_trgmode(self, attr):
        self.debug_stream("In write_trgmode()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.trgmode_write) ENABLED START -----#
        LSTAT = self.picolas.getLSTAT()
        
        if data == 0:
            LSTAT &= ~(1 << 2);
            LSTAT &= ~(1 << 3);
            LSTAT &= ~(1 << 4);
            LSTAT &= ~(1 << 5);
        elif data == 1:
            LSTAT |= (1 << 2);
            LSTAT &= ~(1 << 3);
            LSTAT &= ~(1 << 4);
            LSTAT &= ~(1 << 5);
        elif data == 2:
            LSTAT &= ~(1 << 2);
            LSTAT |= (1 << 3);
            LSTAT &= ~(1 << 4);
            LSTAT &= ~(1 << 5);
        elif data == 3:
            LSTAT |= (1 << 2);
            LSTAT |= (1 << 3);
            LSTAT &= ~(1 << 4);
            LSTAT &= ~(1 << 5);
        elif data == 4:
            LSTAT &= ~(1 << 2);
            LSTAT &= ~(1 << 3);
            LSTAT |= (1 << 4);
            LSTAT &= ~(1 << 5);
        elif data == 5:
            LSTAT |= (1 << 2);
            LSTAT &= ~(1 << 3);
            LSTAT |= (1 << 4);
            LSTAT &= ~(1 << 5);
        else:
            self.picolas.setParameterStatus("Couldn't send command. " + ILGLPARAM_S)
            return
        self.picolas.sendCommand(SETLSTAT_S, LSTAT, SETLSTAT_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.trgmode_write
        
    def is_trgmode_allowed(self, attr):
        self.debug_stream("In is_trgmode_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_trgmode_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_trgmode_allowed
        return state_ok
        
    def read_shots(self, attr):
        self.debug_stream("In read_shots()")
        #----- PROTECTED REGION ID(Picolas.shots_read) ENABLED START -----#
        attr.set_value(self.attr_shots_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.shots_read
        
    def write_shots(self, attr):
        self.debug_stream("In write_shots()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.shots_write) ENABLED START -----#
        self.picolas.sendCommand(SETSHOTS_S, data, SETSHOTS_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.shots_write
        
    def is_shots_allowed(self, attr):
        self.debug_stream("In is_shots_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_shots_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_shots_allowed
        return state_ok
        
    def read_current(self, attr):
        self.debug_stream("In read_current()")
        #----- PROTECTED REGION ID(Picolas.current_read) ENABLED START -----#
        attr.set_value(self.attr_current_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.current_read
        
    def write_current(self, attr):
        self.debug_stream("In write_current()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.current_write) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.current_write
        
    def is_current_allowed(self, attr):
        self.debug_stream("In is_current_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_current_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_current_allowed
        return state_ok
        
    def read_voltage(self, attr):
        self.debug_stream("In read_voltage()")
        #----- PROTECTED REGION ID(Picolas.voltage_read) ENABLED START -----#
        attr.set_value(self.attr_voltage_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.voltage_read
        
    def write_voltage(self, attr):
        self.debug_stream("In write_voltage()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.voltage_write) ENABLED START -----#
        parameter = int(data/30)
        self.picolas.sendCommand(SETVOL_S, parameter, SETVOL_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.voltage_write
        
    def is_voltage_allowed(self, attr):
        self.debug_stream("In is_voltage_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_voltage_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_voltage_allowed
        return state_ok
        
    def read_reprate(self, attr):
        self.debug_stream("In read_reprate()")
        #----- PROTECTED REGION ID(Picolas.reprate_read) ENABLED START -----#
        attr.set_value(self.attr_reprate_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.reprate_read
        
    def write_reprate(self, attr):
        self.debug_stream("In write_reprate()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.reprate_write) ENABLED START -----#
        self.picolas.sendCommand(SETREPRATE_S, data, SETREPRATE_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.reprate_write
        
    def is_reprate_allowed(self, attr):
        self.debug_stream("In is_reprate_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_reprate_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_reprate_allowed
        return state_ok
        
    def read_pulse(self, attr):
        self.debug_stream("In read_pulse()")
        #----- PROTECTED REGION ID(Picolas.pulse_read) ENABLED START -----#
        attr.set_value(self.attr_pulse_read)
        
        #----- PROTECTED REGION END -----#	//	Picolas.pulse_read
        
    def write_pulse(self, attr):
        self.debug_stream("In write_pulse()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Picolas.pulse_write) ENABLED START -----#
        self.picolas.sendCommand(SETPULSEWIDTH_S, data, SETPULSEWIDTH_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.pulse_write
        
    def is_pulse_allowed(self, attr):
        self.debug_stream("In is_pulse_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF,
                PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_pulse_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_pulse_allowed
        return state_ok
        
    
    
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(Picolas.read_attr_hardware) ENABLED START -----#
        status, states, self.attr_pulse_read, self.attr_reprate_read, self.attr_voltage_read, self.attr_current_read, self.attr_shots_read, \
         self.attr_trgmode_read, self.attr_umin_read, self.attr_ocur_read, self.attr_mode_read = self.picolas.getData()
        
        self.set_status(status)
        
        if states["fault"] == True:
            if self.get_state() != PyTango.DevState.OFF:
                self.set_state(PyTango.DevState.OFF)
        if states["error"] == True:
            if status == DEVICE_FAILED or status == TBL_FAIL or status == U_15V_FAIL:
                self.set_status("Briefly disconnect voltage supply!!! " + status)
            else:
                self.set_status("Clean error!!! " + status)
        elif states["fault"] == False and states["calibration"] == False and states["running"] == False:
            if self.get_state() != PyTango.DevState.ON:
                self.set_state(PyTango.DevState.ON)
        elif states["fault"] == False and states["running"] == True and states["calibration"] == False:
            if self.get_state() != PyTango.DevState.RUNNING:
                self.set_state(PyTango.DevState.RUNNING)
        elif states["fault"] == False and states["running"] == False and states["calibration"] == True:
            if self.get_state() != PyTango.DevState.EXTRACT:
                self.set_state(PyTango.DevState.EXTRACT)
        #----- PROTECTED REGION END -----#	//	Picolas.read_attr_hardware


    # -------------------------------------------------------------------------
    #    Picolas command methods
    # -------------------------------------------------------------------------
    
    def calibrate(self):
        """ Carries out a calibration
        """
        self.debug_stream("In calibrate()")
        #----- PROTECTED REGION ID(Picolas.calibrate) ENABLED START -----#
        
        self.picolas.sendCommand(EXECCAL_S, 0, EXECCAL_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.calibrate
        
    def is_calibrate_allowed(self):
        self.debug_stream("In is_calibrate_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_calibrate_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_calibrate_allowed
        return state_ok
        
    def default(self):
        """ Resets all parameters to factory
        """
        self.debug_stream("In default()")
        #----- PROTECTED REGION ID(Picolas.default) ENABLED START -----#
        
        self.picolas.sendCommand(RSTDEF_S, 0, RSTDEF_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.default
        
    def is_default_allowed(self):
        self.debug_stream("In is_default_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_default_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_default_allowed
        return state_ok
        
    def laseron(self):
        """ Activates pulse output
        """
        self.debug_stream("In laseron()")
        #----- PROTECTED REGION ID(Picolas.laseron) ENABLED START -----#
        
        LSTAT = self.picolas.getLSTAT()
        LSTAT |= 0x01;
        self.picolas.sendCommand(SETLSTAT_S, LSTAT, SETLSTAT_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.laseron
        
    def is_laseron_allowed(self):
        self.debug_stream("In is_laseron_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_laseron_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_laseron_allowed
        return state_ok
        
    def laseroff(self):
        """ Deactivates pulse output
        """
        self.debug_stream("In laseroff()")
        #----- PROTECTED REGION ID(Picolas.laseroff) ENABLED START -----#
        
        LSTAT = self.picolas.getLSTAT()
        LSTAT &= ~0x01;
        self.picolas.sendCommand(SETLSTAT_S, LSTAT, SETLSTAT_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.laseroff
        
    def is_laseroff_allowed(self):
        self.debug_stream("In is_laseroff_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_laseroff_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_laseroff_allowed
        return state_ok
        
    def clrerror(self):
        """ Resets the ERROR register
        """
        self.debug_stream("In clrerror()")
        #----- PROTECTED REGION ID(Picolas.clrerror) ENABLED START -----#
        
        self.picolas.sendCommand(CLEARERROR_S, 0, CLEARERROR_R)
        
        #----- PROTECTED REGION END -----#	//	Picolas.clrerror
        
    def is_clrerror_allowed(self):
        self.debug_stream("In is_clrerror_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.EXTRACT])
        #----- PROTECTED REGION ID(Picolas.is_clrerror_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.is_clrerror_allowed
        return state_ok
        

    #----- PROTECTED REGION ID(Picolas.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Picolas.programmer_methods

class PicolasClass(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(Picolas.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Picolas.global_class_variables


    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        }


    #    Command definitions
    cmd_list = {
        'calibrate':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'default':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'laseron':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'laseroff':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'clrerror':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        }


    #    Attribute definitions
    attr_list = {
        'mode':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Mode",
                'description': "If 0 = Frequency Generator \nSets the operating mode to the passed value:\n1 = Voltage Mode \n2 = Current Mode",
            } ],
        'ocur':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Overcurrent",
                'unit': "mA",
                'description': "Sets the maximum current for over-current detection",
            } ],
        'umin':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Min Voltage",
                'unit': "mV",
                'description': "Sets the starting value for calibration",
            } ],
        'trgmode':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Trigger mode",
                'description': "Sets the trigger mode to be used\nmodes:  0 = external trigger, falling edge, arbitrary number of pulses.\n              1 = external trigger, rising edge, arbitrary number of pulses.\n              2 = internal trigger, continuous pulses.\n              3 = same as above.\n              4 = pulsed triggerd, negative.\n              5 = pulsed triggerd, positive.",
            } ],
        'shots':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Number of pulses",
                'description': "Sets the number of pulses to be emitted to the indicated value [Only in trigger mode 0 and 1]",
            } ],
        'current':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Current",
                'unit': "mA",
                'max value': "79000",
                'description': "Sets the pulse current to the indicated value [Only in Current Mode (mode 2)]",
            } ],
        'voltage':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Voltage",
                'unit': "mV",
                'max value': "99000",
                'description': "Sets the precharger voltage of the pulser",
            } ],
        'reprate':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Repeat rate",
                'unit': "Hz",
                'description': "Sets the repeat rate of the pulse",
            } ],
        'pulse':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Pulse width",
                'unit': "ns",
                'max value': "10000",
                'description': "Sets the length of the pulse to be emitted",
            } ],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(PicolasClass, Picolas, 'Picolas')
        #----- PROTECTED REGION ID(Picolas.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Picolas.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed as e:
        print ('-------> Received a DevFailed exception:', e)
    except Exception as e:
        print ('-------> An unforeseen exception occured....', e)

if __name__ == '__main__':
    main()
